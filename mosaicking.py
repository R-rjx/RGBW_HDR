import numpy as np
def mosaicking(image, cfaType):

    if cfaType == 'Hamilton':
        pcfa = np.zeros((8, 8, 3)) # 设置单个彩色滤波阵列
        pcfa[:, :, 0] = [[1, 1, 1, 1, 0, 0, 0, 0], # R通道
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0], ]
        pcfa[:, :, 1] = [[0, 0, 0, 0, 1, 1, 1, 1], # G通道
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [1, 1, 1, 1, 0, 0, 0, 0],
                        [1, 1, 1, 1, 0, 0, 0, 0], ]
        pcfa[:, :, 2] = [[0, 0, 0, 0, 0, 0, 0, 0], # B通道
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [0, 0, 0, 0, 1, 1, 1, 1],
                        [0, 0, 0, 0, 1, 1, 1, 1], ]
    elif cfaType == 'Bayer':
        pcfa = np.zeros((8, 8, 3))  # 设置单个彩色滤波阵列
        pcfa[:, :, 0] = [[1, 0, 1, 0, 1, 0, 1, 0],  # R通道
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 0, 0, 0, 0, 0, 0, 0], ]
        pcfa[:, :, 1] = [[0, 1, 0, 1, 0, 1, 0, 1],  # G通道
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [1, 0, 1, 0, 1, 0, 1, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [1, 0, 1, 0, 1, 0, 1, 0], ]
        pcfa[:, :, 2] = [[0, 0, 0, 0, 0, 0, 0, 0],  # B通道
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1],
                         [0, 0, 0, 0, 0, 0, 0, 0],
                         [0, 1, 0, 1, 0, 1, 0, 1], ]
    else:
        print("不合法的滤波阵列")
        return

    r = pcfa.shape[0] # 单个 CFA 尺寸
    c = pcfa.shape[1]
    rr = image.shape[0] # 图片尺寸
    cc = image.shape[1]
    r_ceil = int(np.ceil(rr / r)) # CFA 需要复制的次数
    c_ceil = int(np.ceil(cc / c))
    cfa = np.tile(pcfa, (r_ceil, c_ceil, 1)) # 水平和垂直复制 CFA，填满整个图片

    image = np.pad(image, ((cfa.shape[0]-rr, 0), (cfa.shape[1]-cc, 0), (0, 0)), 'edge') # 扩展原图像使边缘缺损的CFA补全

    mosaickedImage = image[:, :, 0] * cfa[:, :, 0] + image[:, :, 1] * cfa[:, :, 1] + image[:, :, 2] * cfa[:, :, 2]

    return mosaickedImage